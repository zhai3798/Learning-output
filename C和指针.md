[TOC]

# 第一章 快速上手

gets 函数可能导致溢出  使用fgets解决

# 第二章 基本概念
## 2.1 环境
    环境分为 **编译环境** 和 **执行环境**
    在一个环境编译出另一个环境执行的代码称为 **交叉编译**

# 第三章 数据
## 3.1 基本数据类型
###整形家族
    1.长整形>=整形>=短整型>字符
    2.整形字面值的格式取决于定义时的书写格式 **在default情况下是最短类型但能完整容纳这个值的类型**
        **默认为10进制**：  无修饰   10
        **八进制**：        0开头    012
        **十六进制**:       0x开头   0xA
        **字符常量**：      int类型(固定)  'm'
        **宽字符常量**:              L'm'
###浮点类型
    1.long double >= double >= float
    2.浮点型至少有 "." 6.2 或"e" 6e2
    3.缺省时都为double类型 更改格式在后面加"l","L","f","F"
###指针
    字符串常量也是指针
##3.2 基本声明
###声明指针
    * 理解为间接访问  int * p; p间接访问后得到int类型数据
### typedef
    使用typedef 而不是 #define 定义新类型
##3.6 连接属性(待整理)

# 第五章 操作符和表达式
##5.1操作符
###移位操作符
    >>负数右移是算术右移或逻辑右移是不定的，因此对负数的右移不能保证可移植性
###赋值
    a = x = y+3; 此处当x与y+3类型不符合时，x可能被截断 -> getchar返回值应保存在整形内，若保存在char内会导致返回的结束符被截断，与EOF永远不可能相等
###单目操作符
    ++ 和 -- 都会先对操作对象进行拷贝，对其余表达式表现为该副本。
##5.3 左值与右值
    左值代表位置，右值代表数值
##5.4 表达式求值
###操作符的属性：(待记忆)
###优先级和求值的顺序
    相邻操作符的顺序由优先级决定，**但表达式的求值顺序由编译器决定**此时优先级没有作用： c + --c    + 左操作数与右操作的优先级不定，函数同理
# 第六章 指针
##6.2 值和类型
    同样的32位值 其实际使用数值取决于定义的类型
##6.5 未初始化指针
    **int *a ;  *a = 12;  //a未被分成内存，非法**
##6.6 NULL指针
    NULL指针表示指针未指向任何东西
    不推荐当未找到时将指针返回NULL，此时无法区分是查找执行失败或未查找到指针。
    assert(ptr)
##6.11 指针表达式
    注意左值与右值的区别
##6.13 指针运算
    允许与数组尾元素后的内存指针进行比较，但不允许与数组首元素前的内存指针比较。同时不允许访问最后一个元素后的内存指针。
##6.14 总结
    无法通过值的位模式来判断其类型，对类型的定义时通过使用方法隐式定义由编译器保证的。
# 第七章 函数
##7.6 可变参数列表
    通过stdarg.h中的宏定义实现
# 第八章 数组
##8.1 一维数组
    数组名指针是常量
    下标引用于间接访问表达式相同
    **函数形参内的数组指针只储存第一个数组元素地址，因此函数无法显式的知道数组的长度，除非增加第二个参数/判断标准**
    **准确的说，函数形参内的数组指针只是指向单个元素的指针，而数组指针为指向元素数组的指针，虽然其在使用过程中类似，但sizeof所得到的结果不同**
    char message1[] = {'H','e','l','l','o',0}; == char message = "Hello";
    char *message2 = "Hello"; 与上式不同，此时"Hello"是字符串常量，结果为指针
    message 1                  message 2 
    |'H'|'e'|'l'|'l'|'o'|      |       | -----> |'H'|'e'|'l'|'l'|'o'|
#第九章 字符串、字符和字节
##9.4 长度受限的字符串函数
    to strncpy(dst,src,len)
    str_len >= dst_len   **dst不会以NULL结尾！**
##9.5 字符串查找
##9.8 字符操作
#第十章 结构和联合
##10.1 结构基础知识
   ptr->a == t.a == (*ptr).a    ->为简化操作而生
##10.7 位段
#第十一章 动态内存分配
##11.5 常见错误
    1.忘记检查是否分配成功
    2.访问超出分配边界
    3.忘记释放内存，造成内存泄漏
#第十二章 使用结构和指针
#第十三章 高级指针话题
##13.3 函数指针
    f(25) == (*pt)(25) == pt(25)
    调用函数f时会将其转换为函数指针再进行调用
    **回调函数：** 
    >>search_list(NODE *node, void const *value int (*compare)( void const *, void const *))
    >> int compare_ints(void const *a, void const *b)
    >> {
    >>      if ( *(int *)a == *(int * )b )
    >>          return 0;
    >>      else
    >>          return 1;
    >> }
    **转移表/表驱动/jump_table**
    >> double add (double , double );
    >> double sub (double , double );
    >> double mul (double , double );
    >> double div (double , double );
    >> double (*oper_func[])(double,double) = {add,sub,mul,div};
#第十四章 预处理器
##14.1 预定义符号
    __FILE__ "name.c"
    __LINE__ 25
    __DATE__ "Jan 31 2016"
    __TIME__ "23:16:14"
    __STDC__ 1 (编译器遵循ASIC时=1，否则未定义) 
#第十五章 输入/输出函数
#第十六章 标准库函数
#第十七章 经典抽象数据类型
#第十八章 运行时环境
